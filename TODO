::CORE::
* IsA mechanism in resources blows, have each method do a return _clssid == CLSSID || base::IsA(_clssid) instead of the crap that's going on now
* add audio interface
* implement Background and Foreground
* reimplement collision detection to account for velocity
* implement Entity_Exit and add mechanism to change levels -- level change will be done by the PC entity that collides with it
* decide on BlockBundle implementation to account for animations, location_, have it be abstract enough to allow the implementation of any DisplayAdapter
* implement EntitySpawner and Resource_Entity to load entities
* implement Resource_Level and dependencies to load levels
* add support for a scripting language (think Lua, but I might implement my own, or generate interfaces for any scripting language) so that it will not be necessary to code in c++
== Garbage Collection ==
* Add ref count on Resource
* Run garbage collector after AI loop and display rendering and whatnot until frame time is close to running out (i.e. only clear some resources in the 17/34 miliseconds)
* adapt it so that if it ever takes too much time, make it be less aggressive
== Parallelisation ==
* store entities in something that openMP can run over
* I guess a lazy vector would be good, and then based on the time left in a frame start moving items to the left and maybe resize it down
* screen::add/removeEntity have locks
* D123:: add locks to have continuous logging output from one thread at a time
* add OpenMP for AI loops (where aplicable) and rendering (where aplicable, entity buffer)

::RES::
* low priority
* resources will be stored in compressed files and the Resource adapters will need to read their data from a stream rather than from a file
* add some rudimentary encryption

::GEOM::
* reimplement collision detection to be more general (the current one is stupid)

::DOC::
* add documentation for interfaces in the source files
* add docomentation for why things work as they do
* write the README

::DEMO::
== GTK demo ==
* add png renderer
* add moving entities
* add some pool-ball moving logic
* add input interface (keyboard, mouse, gamepad)
== Scripting demo ==
* depends on scripting support in Core
* TODO
== Advanced demo ==
* TODO
* should use some real graphics engine like Irrlicht

::MISC::
* finish up TODO list
* attach some issue-tracking system to the project to set long term goals and set up some planning
